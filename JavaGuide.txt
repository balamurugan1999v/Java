Java My refresher Document

----

Wrapper class:
It is used to convert the data from primitive data type to Objects.
For example:
Int i = 10; --> Primitive datatype
Interger intValue = new Integer(i); --> Wrapper class.

----

JDK :
	Java Development Kit -->  
		Providing all the dependacies to develop the program.(Dev tools)
		It is used to compile the code in the development phase.
		It is used to convert the java file into class file.
		It contains JRE and JVM
		JRE + Development tools = JDK


JRE :
	Java Runtime Environment --> It is allow the class file to execute on the environment. It doesn't allow to compile the code. It will contains executable libraries in it.
	JVM is a one of the part of JRE.	
	JVM + Libraries = JRE
	
	
JVM : 
	Java Virtual Machine --> 
		Here only the executed class file will run.
		It is executing the program line by line.
		It is the key part for both JVM and JDK.
			

----

Access Modifiers:
	Default - If we not mentioned anything then it will be default access modifier. It can be accessible only inside the package.
	
	Private - Only accessible in the class
	
	Protected - Only accessible with in the package and child class of the other package.
	
	Public - Accessible any where in the code.
	
----

Class :
	It represent the structure. Contains the variables and methods.
	
	public class classname
	e.g  -->
	public class Student{
	}

Objects : 
	If class is lock then objects is keys. By using the objects only we can access the variables and methods inside the class.
	
	Classname objectName = new Classname();
	
	Student student = new Student();
----

OOPS:
	1. Abstraction
	2. Encapsulation
	3. Inheritance
	4. Polymorphism
	
Abstraction:
	* We can able to see only the output of the functionality. It will hide all the processes.
	* It can be acheived by abstract keyword and interfaces
	* Example with Abstract keyword, here abstract have only defined the methods names actual implementations in the another place but by seeing this abstract method we can able to understand the objective of the code.
	abstract class A{
		abstract void print(); // abstract method, here we can create concerete methods as well
	}
	
	class B extends A{
		void print(){
			System.out.println("Printing");
		}
		
		public static void main(String args[]){
			A obj = new B();
			obj.print();
		}
	}
	
	If we use interfaces
	
	Interface shape{
		double calculateArea();
	}
	
	Class circle implements shape{
		public circle(double radius){
			this.radius = radius;
		}
		
		public double calculateArea(){
			return (radius * radius * (22/7));
		}
	}
	
	Class square implements shape{
		public square(double length){
			this.length = length;
		}
		
		public double calculateArea(){
			return (4 * length);
		}
	}
	
	
	
Encapsulation:
	* We are not able to access the private class variables outside of the class but by using this we can able to access the private method values outside of the class.
	* Example -> Getter and setters
	* Hiding the implementation details to outside classes.
	
	Example:
	
	class Example{
		private name ;
		
		public String getName(){
			return this.name;
		}
		
		public void setName(String name){
			this.name = name;
		}
	}
	
	Here name is private directly other class not able to access it but by using this getter and setter other classes can read the data, update the data.
	
	Advantage:
		1. we have access control over data. It is allow us to make class or object as read-write and read only access. If we not allowed/write setter then it will be read only obj data will be set during the object creation only.
		2. Reusability we can use the same getter any where of the place if we need that data.
	
	
Polymorphism:

	* Method overloading and overriding is the example of Polymorphism
	
	
	
Inheritance:
	It is accessing the parent classes from the child classes.
	
	* Public class A extends B --> here A is child and B is parent.
	* Each member for B can able to access by A's object but B's object not able to access the A. CHild can access parent class but parent class not able to access the child class.
	* If access modifier protected in Parent then Private is not possible in the child for same method name(During the override).
	
---
Play area 1:
Diamond Program:

https://github.com/balamurugan1999v/Java/blob/main/PractiseJava/src/Pattern/Diamond.java	

    * 
   * * 
  * * * 
 * * * * 
* * * * * 
 * * * * 
  * * * 
   * * 
    * 


---

Constructors:

	There are three types of Constructors those are default constructor, parameterized constructor and copy constructor.
	
	class A{
		public A(){
		}
	}
	
	class AB{
		public AB(String name){
		}
	}
	
	class copyConstructor{
		public copyConstructor(String name){
			this.name = name;
		}
		
		public copyConstructor(copyConstructor object){
			this.name = object.name;
		}
	}
	
	copyConstructor a = new copyConstructor("Learning");
	copyConstructor b = new copyConstructor(a);
	
---

JAVA 8 Features:
	One of the feature is called stream.
	
Stream API:
		It is not a data structure, it will take a data from collections or Arrays and return as stream.
		It wont change the source collections/Arrays data only produce the result as per the logic written
		It is contains two type of operations 
			1. Intermediate operations
			2. Terminate operations
			
			Example:
			 Input --> Process1 --> process2 --> process3 --> Last process --> Output
			 
			Here process1,2,3 are intermediate process and last process is terminate process
		1. Intermediate operations:
			Methods are chained together.
			Intermediate operations transform a stream into another stream.
			It enables the concept of filtering where one method filters data and passes it to another method after processing.
			
			Some of the keywords for Intermediate operations
			1. map() -> It is used to perform of the operation given in the bracket
			2. filter() --> It will act as a conditional operation
			3. sorted() -> It will sort the data based on our input
			4. flatMap() --> It will perform in the collection of collection
			5. peek() --> If we want to perform any add action to any other collection we can use this
			6. distinct() --> It is used to remove the duplicates.
			
			Example program:
				 List<List<String>> listOfLists = Arrays.asList(
						Arrays.asList("Reflection", "Collection", "Stream"),
						Arrays.asList("Structure", "State", "Flow"),
						Arrays.asList("Sorting", "Mapping", "Reduction", "Stream")
					);

				
				Set<String> intermediateResults = new HashSet<>();

				
				List<String> result = listOfLists.stream()
					.flatMap(List::stream)               // Flatten the list of lists into a single stream
					.filter(s -> s.startsWith("S"))      // Filter elements starting with "S"
					.map(String::toUpperCase)            // Transform each element to uppercase
					.distinct()                          // Remove duplicate elements
					.sorted()                            // Sort elements
					.peek(s -> intermediateResults.add(s)) // Perform an action (add to set) on each element
					.collect(Collectors.toList());       // Collect the final result into a list
				
				System.out.println(result);

		2. Terminate operations:
			It is used to return the result. Basically last operation by using this we can get only output.
			
			Key methods:
				1. collect() --> It is used to collect the result into any of the structure like list,set.
				2. foreach() --> It is used to iterate all the elements present in the stream.
					
				3. reduce() --> Convert stream into single value
				4. allMatch() --> By passing a condition it will check all the value present inside the stream matching or not if it is matching then output will be true else false.
				5. anyMatch() --> It will be opposite of allMatch(). If will return true any of the value in the stream match for the given condition.
				6. findFirst() --> It will collect the very first value of the given condition.
				7. count() --> It will return the size of the stream.
				
			Example:
				
				List<String> names = Arrays.asList(
					"Reflection", "Collection", "Stream",
					"Structure", "Sorting", "State"
				);
				//foreach
				names.stream().forEach(System.out::println);

				// collect: Collect names starting with 'S' into a list
				List<String> sNames = names.stream()
										   .filter(name -> name.startsWith("S"))
										   .collect(Collectors.toList());

				// reduce: Concatenate all names into a single string
				String concatenatedNames = names.stream().reduce(
					"",
					(partialString, element) -> partialString + " " + element
				);
				
				// count: Count the number of names
				long count = names.stream().count();
				
				// findFirst: Find the first name
				Optional<String> firstName = names.stream().findFirst();

				// allMatch: Check if all names start with 'S'
				boolean allStartWithS = names.stream().allMatch(
					name -> name.startsWith("S")
				);
				
				// anyMatch: Check if any name starts with 'S'
				boolean anyStartWithS = names.stream().anyMatch(
					name -> name.startsWith("S")
				);


------------